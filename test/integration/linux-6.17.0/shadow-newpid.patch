diff -Nupr src.orig/fs/proc/array.c src/fs/proc/array.c
--- src.orig/fs/proc/array.c	2025-11-14 13:00:30.746093746 -0300
+++ src/fs/proc/array.c	2025-11-14 13:59:53.699363889 -0300
@@ -145,7 +145,7 @@ static inline const char *get_task_state
 	return task_state_array[task_state_index(tsk)];
 }
 
-static inline void task_state(struct seq_file *m, struct pid_namespace *ns,
+static __always_inline void task_state(struct seq_file *m, struct pid_namespace *ns,
 				struct pid *pid, struct task_struct *p)
 {
 	struct user_namespace *user_ns = seq_user_ns(m);
@@ -395,12 +395,19 @@ static inline void task_seccomp(struct s
 	seq_putc(m, '\n');
 }
 
+#include <linux/livepatch.h>
 static inline void task_context_switch_counts(struct seq_file *m,
 						struct task_struct *p)
 {
+	int *newpid;
+
 	seq_put_decimal_ull(m, "voluntary_ctxt_switches:\t", p->nvcsw);
 	seq_put_decimal_ull(m, "\nnonvoluntary_ctxt_switches:\t", p->nivcsw);
 	seq_putc(m, '\n');
+
+	newpid = klp_shadow_get(p, 0);
+	if (newpid)
+		seq_printf(m, "newpid:\t%d\n", *newpid);
 }
 
 static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
diff -Nupr src.orig/kernel/exit.c src/kernel/exit.c
--- src.orig/kernel/exit.c	2025-11-14 13:00:31.154098292 -0300
+++ src/kernel/exit.c	2025-11-14 13:01:14.887585603 -0300
@@ -889,6 +889,7 @@ static void synchronize_group_exit(struc
 		coredump_task_exit(tsk, core_state);
 }
 
+#include <linux/livepatch.h>
 void __noreturn do_exit(long code)
 {
 	struct task_struct *tsk = current;
@@ -964,6 +965,8 @@ void __noreturn do_exit(long code)
 	sched_autogroup_exit_task(tsk);
 	cgroup_exit(tsk);
 
+	klp_shadow_free(tsk, 0, NULL);
+
 	/*
 	 * FIXME: do that only when needed, using sched_exit tracepoint
 	 */
diff -Nupr src.orig/kernel/fork.c src/kernel/fork.c
--- src.orig/kernel/fork.c	2025-11-14 13:00:31.154098292 -0300
+++ src/kernel/fork.c	2025-11-14 13:01:14.889741434 -0300
@@ -2561,6 +2561,7 @@ struct task_struct *create_io_thread(int
  *
  * args->exit_signal is expected to be checked for sanity by the caller.
  */
+#include <linux/livepatch.h>
 pid_t kernel_clone(struct kernel_clone_args *args)
 {
 	u64 clone_flags = args->flags;
@@ -2569,6 +2570,8 @@ pid_t kernel_clone(struct kernel_clone_a
 	struct task_struct *p;
 	int trace = 0;
 	pid_t nr;
+	int *newpid;
+	static int ctr = 0;
 
 	/*
 	 * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument
@@ -2608,6 +2611,11 @@ pid_t kernel_clone(struct kernel_clone_a
 	if (IS_ERR(p))
 		return PTR_ERR(p);
 
+	newpid = klp_shadow_get_or_alloc(p, 0, sizeof(*newpid), GFP_KERNEL,
+					 NULL, NULL);
+	if (newpid)
+		*newpid = ctr++;
+
 	/*
 	 * Do this prior waking up the new thread - the thread pointer
 	 * might get invalid after that point, if the thread exits quickly.
